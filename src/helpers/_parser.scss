////
/// Parsing engine
/// @author Kitty Giraudel
/// @access private
////

///
/// Get operator of an expression
///
/// @param {String} $expression - Expression to extract operator from
///
/// @return {String} - Any of `>=`, `>`, `<=`, `<`, `≥`, `≤`
///
@function get-expression-operator($expression) {
  @each $operator in ('>=', '>', '<=', '<', '≥', '≤') {
    @if string.index($expression, $operator) {
      @return $operator;
    }
  }

  @error 'No operator found in `#{$expression}`.';
}

///
/// Get dimension of an expression, based on a found operator
///
/// @param {String} $expression - Expression to extract dimension from
/// @param {String} $operator - Operator from `$expression`
///
/// @return {String} - `width` or `height` (or potentially anything else)
///
@function get-expression-dimension($expression, $operator) {
  $operator-index: string.index($expression, $operator);
  $parsed-dimension: string.slice($expression, 0, $operator-index - 1);
  $parsed-dimension: str-trim($parsed-dimension);
  $dimension: 'width';

  @if string.length($parsed-dimension) > 0 {
    $dimension: $parsed-dimension;
  }

  @return $dimension;
}

///
/// Get dimension prefix based on an operator
///
/// @param {String} $operator - Operator
///
/// @return {String} - `min` or `max`
///
@function get-expression-prefix($operator) {
  @if list.index(('<', '<=', '≤'), $operator) {
    @return 'max';
  } @else {
    @return 'min';
  }
}

///
/// Get value of an expression, based on a found operator
///
/// @param {String} $expression - Expression to extract value from
/// @param {String} $operator - Operator from `$expression`
/// @param {Bool} $apply-interval - Whether to apply unit intervals (default: true)
///
/// @return {Number} - A numeric value
///
@function get-expression-value($expression, $operator, $apply-interval: true) {
  $operator-index: string.index($expression, $operator);
  $value: string.slice($expression, $operator-index + string.length($operator));
  $trimmedValue: str-trim($value);

  @if map.has-key($breakpoints, $trimmedValue) {
    $value: map.get($breakpoints, $trimmedValue);
  } @else {
    $value: to-number($trimmedValue);
  }

  $interval: map.get($unit-intervals, math.unit($value));

  @if not $interval {
    @error 'Unknown unit `#{math.unit($value)}`.';
  }

  // Only apply interval adjustments for legacy syntax (not range syntax)
  @if $apply-interval {
    @if $operator == '>' {
      $value: $value + $interval;
    } @else if $operator == '<' {
      $value: $value - $interval;
    }
  }

  @return $value;
}

///
/// Check if an expression contains the clamping operator (&)
///
/// @param {String} $expression - Expression to check
///
/// @return {Bool} - True if expression contains &
///
@function is-clamping-expression($expression) {
  @return string.index($expression, '&') != null;
}

///
/// Invert an operator for range syntax
/// >phone means "width > phone", which in range syntax is "phone < width"
///
/// @param {String} $operator - Operator to invert
///
/// @return {String} - Inverted operator
///
@function invert-operator($operator) {
  @if $operator == '>' {
    @return '<';
  } @else if $operator == '>=' or $operator == '≥' {
    @return '<=';
  } @else if $operator == '<' {
    @return '>';
  } @else if $operator == '<=' or $operator == '≤' {
    @return '>=';
  }
  @return $operator;
}

///
/// Normalize Unicode operators to ASCII equivalents
///
/// @param {String} $operator - Operator to normalize
///
/// @return {String} - Normalized operator
///
@function normalize-operator($operator) {
  @if $operator == '≥' {
    @return '>=';
  } @else if $operator == '≤' {
    @return '<=';
  }
  @return $operator;
}

///
/// Parse a clamping expression (e.g., '>phone&<=tablet') into range syntax
///
/// @param {String} $expression - Clamping expression to parse
///
/// @return {String} - Valid media query with range syntax
///
@function parse-clamping-expression($expression) {
  $and-index: string.index($expression, '&');

  @if not $and-index {
    @error 'Invalid clamping expression `#{$expression}`. Expected & operator.';
  }

  // Split into left and right expressions
  $left-expr: str-trim(string.slice($expression, 1, $and-index - 1));
  $right-expr: str-trim(string.slice($expression, $and-index + 1));

  // Parse left side
  $left-operator: get-expression-operator($left-expr);
  $left-dimension: get-expression-dimension($left-expr, $left-operator);
  $left-value: get-expression-value($left-expr, $left-operator, $im-use-range-syntax == false);

  // Parse right side
  $right-operator: get-expression-operator($right-expr);
  $right-dimension: get-expression-dimension($right-expr, $right-operator);
  $right-value: get-expression-value($right-expr, $right-operator, $im-use-range-syntax == false);

  // Validate that both expressions use the same dimension
  @if $left-dimension != $right-dimension {
    @error 'Clamping expressions must use the same dimension. Got `#{$left-dimension}` and `#{$right-dimension}` in `#{$expression}`.';
  }

  @if $im-use-range-syntax {
    // Modern range syntax: (320px < width <= 768px)
    // Invert operators: >phone means "width > phone" → "phone < width"
    $left-inverted: invert-operator($left-operator);
    $right-inverted: invert-operator($right-operator);

    // Determine the order based on operators
    @if list.index(('>', '>=', '≥'), $left-operator) {
      // Left is min bound: >phone becomes 320px < width
      @return '(#{$left-value} #{$left-inverted} #{$left-dimension} #{$right-operator} #{$right-value})';
    } @else {
      // Left is max bound, swap order
      @return '(#{$right-value} #{$right-inverted} #{$right-dimension} #{$left-operator} #{$left-value})';
    }
  } @else {
    // Legacy syntax: combine with 'and'
    $left-prefix: get-expression-prefix($left-operator);
    $right-prefix: get-expression-prefix($right-operator);
    @return '(#{$left-prefix}-#{$left-dimension}: #{$left-value}) and (#{$right-prefix}-#{$right-dimension}: #{$right-value})';
  }
}

///
/// Parse an expression to return a valid media-query expression
///
/// @param {String} $expression - Expression to parse
///
/// @return {String} - Valid media query
///
@function parse-expression($expression) {
  // If it is part of $media-expressions, it has no operator
  // then there is no need to go any further, just return the value
  @if map.has-key($media-expressions, $expression) {
    @return map.get($media-expressions, $expression);
  }

  // Check for clamping expression with &
  @if is-clamping-expression($expression) {
    @return parse-clamping-expression($expression);
  }

  $operator: get-expression-operator($expression);
  $dimension: get-expression-dimension($expression, $operator);
  $prefix: get-expression-prefix($operator);
  $value: get-expression-value($expression, $operator, $im-use-range-syntax == false);

  @if $im-use-range-syntax {
    // Modern range syntax: (width > 320px)
    @return '(#{$dimension} #{normalize-operator($operator)} #{$value})';
  } @else {
    // Legacy syntax: (min-width: 321px)
    @return '(#{$prefix}-#{$dimension}: #{$value})';
  }
}
